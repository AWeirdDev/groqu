/// Groq models. Descriptions are literally generated by AI because this is an AI platform

use std::marker::PhantomData;

use ijson::{ ijson, IValue };
use serde::{ Deserialize, Serialize };
use base64::{ engine::general_purpose, Engine as _ };

#[derive(Debug, Clone, Default, Serialize)]
pub struct ChatCompletionRequest {
    /// ID of the model to use
    pub model: IValue,
    /// A list of messages comprising the conversation so far
    pub messages: IValue,
    /// What sampling temperature to use, between 0 and 2
    #[serde(skip_serializing_if = "Option::is_none")]
    pub temperature: Option<f32>,
    /// An alternative to sampling with temperature, called nucleus sampling
    #[serde(skip_serializing_if = "Option::is_none")]
    pub top_p: Option<f32>,
    /// How many chat completion choices to generate for each input message
    #[serde(skip_serializing_if = "Option::is_none")]
    pub n: Option<u32>,
    /// Up to 4 sequences where the API will stop generating further tokens
    #[serde(skip_serializing_if = "Option::is_none")]
    pub stop: Option<StopSequence>,
    /// The maximum number of tokens that can be generated in the chat completion
    #[serde(skip_serializing_if = "Option::is_none")]
    pub max_completion_tokens: Option<u32>,
    /// Number between -2.0 and 2.0 affecting frequency penalty
    #[serde(skip_serializing_if = "Option::is_none")]
    pub frequency_penalty: Option<f32>,
    /// Number between -2.0 and 2.0 affecting presence penalty
    #[serde(skip_serializing_if = "Option::is_none")]
    pub presence_penalty: Option<f32>,
    /// Specifies how to output reasoning tokens
    #[serde(skip_serializing_if = "Option::is_none")]
    pub reasoning_format: Option<String>,
    /// An object specifying the format that the model must output
    #[serde(skip_serializing_if = "Option::is_none")]
    pub response_format: Option<ResponseFormat>,
    /// For deterministic sampling
    #[serde(skip_serializing_if = "Option::is_none")]
    pub seed: Option<u64>,
    /// A unique identifier representing your end-user
    #[serde(skip_serializing_if = "Option::is_none")]
    pub user: Option<String>,
}

impl<'a> ChatCompletionRequest {
    pub fn builder() -> _ChatCompletionRequestBuilder<'a> {
        _ChatCompletionRequestBuilder {
            ph: Default::default(),
            rq: ChatCompletionRequest::default(),
        }
    }
}

#[derive(Debug)]
pub struct _ChatCompletionRequestBuilder<'a> {
    ph: PhantomData<&'a ()>,
    rq: ChatCompletionRequest,
}

impl _ChatCompletionRequestBuilder<'_> {
    pub fn model<K: AsRef<str>>(mut self, name: K) -> Self {
        self.rq.model = IValue::from(name.as_ref());
        self
    }

    pub fn messages(mut self, messages: &[ChatMessage]) -> Self {
        self.rq.messages = ijson!(messages);
        self
    }

    pub fn temperature(mut self, tmp: f32) -> Self {
        self.rq.temperature = Some(tmp);
        self
    }

    pub fn top_p(mut self, p: f32) -> Self {
        self.rq.top_p = Some(p);
        self
    }

    pub fn n(mut self, x: u32) -> Self {
        self.rq.n = Some(x);
        self
    }

    pub fn stop(mut self, seq: StopSequence) -> Self {
        self.rq.stop = Some(seq);
        self
    }

    pub fn stop_single(mut self, token: String) -> Self {
        self.rq.stop = Some(StopSequence::Single(token));
        self
    }

    pub fn stop_multiple(mut self, tokens: Vec<String>) -> Self {
        self.rq.stop = Some(StopSequence::Multiple(tokens));
        self
    }

    pub fn max_completion_tokens(mut self, n: u32) -> Self {
        self.rq.max_completion_tokens = Some(n);
        self
    }

    pub fn frequency_penalty(mut self, x: f32) -> Self {
        self.rq.frequency_penalty = Some(x);
        self
    }

    pub fn presence_penalty(mut self, x: f32) -> Self {
        self.rq.presence_penalty = Some(x);
        self
    }

    pub fn reasoning_format(mut self, fmt: String) -> Self {
        self.rq.reasoning_format = Some(fmt);
        self
    }

    pub fn response_format(mut self, fmt: String) -> Self {
        self.rq.response_format = Some(ResponseFormat { r#type: fmt });
        self
    }

    pub fn seed(mut self, x: u64) -> Self {
        self.rq.seed = Some(x);
        self
    }

    pub fn user(mut self, id: String) -> Self {
        self.rq.user = Some(id);
        self
    }

    pub fn build(self) -> ChatCompletionRequest {
        self.rq
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatMessage {
    /// The role of the message author
    pub role: ChatRole,
    /// The content of the message
    pub content: ContentType,
    /// Optional name for the message author
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

macro_rules! messagerole {
    ($name:ident, $e:expr) => {
        pub fn $name(content: impl Into<ContentType>, name: Option<String>) -> Self {
            Self { role: $e, content: content.into(), name }
        }
    };
}

impl ChatMessage {
    messagerole!(system, ChatRole::System);
    messagerole!(assistant, ChatRole::Assistant);
    messagerole!(user, ChatRole::User);
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ContentType {
    /// Text content type.
    Text(String),
    /// Array of content parts.
    Parts(Vec<ContentPart>),
}

impl ContentType {
    pub fn text(x: String) -> Self {
        Self::Text(x)
    }

    pub fn text_and_image<T: Into<ContentPart>, I: Into<ContentPart>>(a: T, b: I) -> Self {
        Self::Parts(vec![a.into(), b.into()])
    }

    pub fn get_text(self) -> String {
        match self {
            Self::Text(t) => t,
            _ => panic!("Expected text"),
        }
    }
}

impl<K: ToString> From<K> for ContentType {
    fn from(value: K) -> Self {
        Self::Text(value.to_string())
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ContentPart {
    /// A text content part.
    Text {
        r#type: String,
        /// The text.
        text: String,
    },
    /// An image content part. Requires an [`ImageUrl`] object.
    Image {
        r#type: String,
        /// The image.
        image_url: ImageUrl,
    },
}

impl ContentPart {
    pub fn text(text: String) -> Self {
        Self::Text {
            r#type: String::from("text"),
            text,
        }
    }

    pub fn image(image_url: ImageUrl) -> Self {
        Self::Image { r#type: String::from("image_url"), image_url }
    }

    pub fn image_url(url: String) -> Self {
        Self::Image { r#type: String::from("image_url"), image_url: ImageUrl::new_url(url) }
    }

    pub fn image_png(image: &[u8]) -> Self {
        Self::Image { r#type: String::from("image_url"), image_url: ImageUrl::new_png(image) }
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ImageUrl {
    pub url: String,
}

impl ImageUrl {
    pub fn new_png(image: &[u8]) -> Self {
        Self {
            url: format!("data:image/png;base64,{}", general_purpose::STANDARD.encode(image)),
        }
    }

    pub fn new_url(url: String) -> Self {
        Self { url }
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "lowercase")]
pub enum ChatRole {
    System,
    Assistant,
    User,
}

#[derive(Debug, Clone, Serialize)]
#[serde(untagged)]
pub enum StopSequence {
    Single(String),
    Multiple(Vec<String>),
}

#[derive(Debug, Clone, Serialize)]
pub struct ResponseFormat {
    /// The type of response format
    pub r#type: String,
}

#[derive(Debug, Clone, Deserialize, Default)]
pub struct ChatCompletionResponse {
    /// The list of completion choices
    pub choices: Option<Vec<ChatCompletionChoice>>,
}

#[derive(Debug, Clone, Deserialize)]
pub struct ChatCompletionChoice {
    /// The index of this completion choice
    pub index: usize,
    /// The message produced by the model
    pub message: ChatMessage,
    /// The reason the model stopped generating tokens
    pub finish_reason: String,
}
